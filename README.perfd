Perfd
=====

Perfd is a proof-of-concept implementation of Torperf using Twisted

 - Sets up an HTTP server that serves random data for performance
   tests.

 - Periodically requests 50 KiB of data from its own HTTP server via
   Tor (or a local SOCKS proxy in general) and logs timestamps.


Howto
-----

On Debian, get Twisted core, Twisted Web, and Tor:
  apt-get install python-twisted-core python-twisted-web tor

Clone twisted-socks and create a symbolic Link to its main source file:
  git clone https://github.com/kloesing/twisted-socks
  ln -s twisted-socks/src/socksclient.py .

For local testing, run local Twisted SOCKS proxy:
  twistd -n socks

For Tor testing, edit PUBLIC_IP and SOCKS_PORT at the bottom of perfd.py.

Start Perfd service which runs in the background:
  ./perfd start

To restart or stop the service, run
  ./perfd restart
or
  ./perfd stop

Logs are written to perfd.log.  Look out for this log message indicating a
successful (local-only) Perfd run:

2013-01-22 21:26:13+0100 [SOCKSv4ClientProtocol,client] \
START=1358886373.87 CONNECT=1358886373.88 DATACOMPLETE=1358886373.88


Next steps
----------

A  Reach feature parity with current Torperf

1 Use txtorcon, available at https://github.com/meejah/txtorcon, to set up
  local tor clients, configure them, and register for events.  Send
  feedback and enhancement requests to meejah using GitHub's Issues
  interface.

2 Decide on a Twisted SOCKS client implementation and extend it to capture
  more timestamps.  Options are:
  - adapting Linus' twisted-socks that we currently use,
  - adapting Arturo's https://github.com/hellais/txsocksx which he says
    has decent test coverage and which supports v4 and v5, or
  - writing our own implementation that's loosely based on Linus' or
    Arturo's implementation, our trivsocks-client C implementation, and
    maybe tor-resolve.py in tor's contrib/.

3 Use a database, maybe SQLite, to store request timestamps and controller
  events and to provide results via the same web server that is used for
  measurements.  Either offer results in JSON format, or (preferably) in
  Torperf's key=value format.


B  Make measurement results more realistic

4 Integrate Will Scott's pagespeed prototype that uses Selenium/Firefox
  (not PhantomJS) available at https://github.com/willscott/pagespeed.
  meejah suspects that all we need to make this work is Twisted's
  event-based subprocess launching which txtorcon uses to launch slave
  Tors.

5 Ponder adding a measuring proxy between Firefox and Tor to capture more
  timestamps.  One option might be Rob van der Hoeven's Monitor In The
  Middle, available at http://freedomboxblog.nl/mitm-for-tor/, which is
  based on Twisted.  Other options might be BrowserMob, dynaTrace,
  HttpWatch, or Watir.  Special focus should be on easy of deployment.

6 Run a parallel Torperf with a Firefox with the optimistic data patch.
  See #3875 for the optimistic data patch.


C  Add more performance tests

7 Add a test that runs a series of requests to track stream/circ
  allocations for #5830.  meejah says there are some decent examples in
  txtorcon's exit_scanner branch and in examples/circuit_failure_rates.py.

8 Write a test that measures upload speed using HTTP POST requests for
  #7010.

9 Add a performance test to a locally running hidden service.  meejah says
  that a super-simple version of this is already included in tortxcon in
  examples/launch_tor_with_hidden_service.py and that adding timing code
  would be easy.

